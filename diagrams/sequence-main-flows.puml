@startuml sequence-main-flows
!theme blueprint
skinparam responseMessageBelowArrow true
skinparam sequenceMessageAlign center

title Flujos Principales: Ingesta de PDFs, Generación de Recomendaciones y Operación

actor "Email Inbox\nRhenus" as Inbox
participant "Cloud\nPub/Sub" as PubSub
participant "Ingestion\nFunction" as Ingestion
participant "Cloud\nStorage" as Storage
participant "Gemini\n(Vertex AI)" as Gemini
database "PostgreSQL" as DB
participant "API\nFunction" as API
participant "Timefold\nEngine\n(Cloud Run)" as Timefold
actor "Operador\nRhenus" as Operator
participant "Web\nApplication" as WebApp

== Flujo 1: Ingesta de PDFs desde Email ==

Inbox -> PubSub: Nuevo email con PDF\n(orden import/export o\nllegada ferroviaria)
activate PubSub
PubSub -> Ingestion: Trigger evento
activate Ingestion
deactivate PubSub

Ingestion -> Inbox: Descarga PDF del email
Inbox --> Ingestion: PDF bytes

Ingestion -> Storage: Almacena PDF original
activate Storage
Storage --> Ingestion: URL almacenamiento
deactivate Storage

Ingestion -> Gemini: Solicita extracción de datos\n(análisis visual multimodal)
activate Gemini
Gemini --> Gemini: Procesa PDF\nExtrae datos estructurados
Gemini --> Ingestion: JSON con datos extraídos\n+ confidence scores
deactivate Gemini

Ingestion -> Ingestion: Validación anti-alucinaciones:\n- Consistencia de datos\n- Campos obligatorios\n- Rangos esperados\n- Confidence thresholds

alt Validación exitosa
    Ingestion -> DB: INSERT orden (import/export)\nO INSERT llegada ferroviaria
    activate DB
    DB --> Ingestion: Orden/llegada almacenada

    Ingestion -> DB: UPDATE stock de contenedores\n(si llegada ferroviaria)
    DB --> Ingestion: Stock actualizado
    deactivate DB

    Ingestion -> API: Trigger: Nueva orden procesada
    note right: Continúa en Flujo 2

else Validación fallida o baja confianza
    Ingestion -> DB: INSERT orden con estado\n"PENDING_REVIEW"
    activate DB
    DB --> Ingestion: Guardada para revisión
    deactivate DB

    Ingestion -> WebApp: Notificación: Requiere\nrevisión manual
    note right: Operador valida\nmanualmente
end

deactivate Ingestion

== Flujo 2: Generación de Recomendaciones ==

API -> API: Activado por:\n- Nueva orden export\n- Nueva orden import\n- Actualización de stock
activate API

API -> DB: SELECT órdenes export pendientes
activate DB
DB --> API: Lista órdenes export

API -> DB: SELECT contenedores vacíos:\n- En terminales\n- Post-import en clientes
DB --> API: Stock de vacíos disponibles

API -> DB: SELECT ubicaciones de clientes
DB --> API: Coordenadas geográficas
deactivate DB

API -> Timefold: POST /optimize\n{\n  ordenes_export,\n  contenedores_vacios,\n  ubicaciones,\n  parametros_optimizacion\n}
activate Timefold

Timefold -> Timefold: Algoritmo de matching:\n- Proximidad geográfica\n- Compatibilidad de tipos\n- Ventanas temporales\n- Restricciones de navieras

Timefold -> Timefold: Optimización multiobjetivo:\n- Minimizar coste\n- Minimizar tiempo\n- Minimizar CO2\n- Maximizar utilización

Timefold --> API: JSON recomendaciones:\n[\n  {\n    import_order_id,\n    export_order_id,\n    ruta_propuesta,\n    ahorro_estimado,\n    confidence_score\n  }\n]
deactivate Timefold

API -> DB: INSERT recomendaciones\ncon estado "PENDING"
activate DB
DB --> API: Recomendaciones almacenadas
deactivate DB

API -> WebApp: Notificación en tiempo real:\nNuevas recomendaciones disponibles
deactivate API

== Flujo 3: Operación de Operadores Rhenus ==

Operator -> WebApp: Accede al dashboard
activate WebApp

WebApp -> API: GET /recommendations?status=PENDING
activate API
API -> DB: SELECT recomendaciones\ncon detalles de órdenes
activate DB
DB --> API: Lista recomendaciones completas
deactivate DB
API --> WebApp: JSON recomendaciones
deactivate API

WebApp --> Operator: Visualiza recomendaciones:\n- Matching import-export\n- Mapa geográfico\n- Ahorro estimado\n- Confidence score

Operator -> Operator: Revisa recomendación:\n- Valida viabilidad\n- Considera restricciones\n- Toma decisión

alt Operador ACEPTA recomendación
    Operator -> WebApp: Acepta recomendación
    WebApp -> API: PUT /recommendations/{id}\n{\n  status: "ACCEPTED",\n  operator_id,\n  timestamp\n}
    activate API
    API -> DB: UPDATE recomendación\nstatus = "ACCEPTED"
    activate DB
    DB --> API: Actualizado
    deactivate DB
    API --> WebApp: Confirmación
    deactivate API

    WebApp --> Operator: Confirmación: Recomendación aceptada\n(Operador genera orden de transporte\nen sistema externo)

else Operador RECHAZA recomendación
    Operator -> WebApp: Rechaza con motivo:\n- Cliente no disponible\n- Restricción de naviera\n- Timing no compatible\n- Otro
    WebApp -> API: PUT /recommendations/{id}\n{\n  status: "REJECTED",\n  rejection_reason,\n  operator_id,\n  timestamp\n}
    activate API
    API -> DB: UPDATE recomendación\nstatus = "REJECTED"\nGuarda motivo para aprendizaje
    activate DB
    DB --> API: Actualizado
    deactivate DB
    API --> WebApp: Confirmación
    deactivate API

    WebApp --> Operator: Recomendación marcada como rechazada
    note right: Feedback utilizado para\nmejora continua del algoritmo
end

deactivate WebApp

@enduml
